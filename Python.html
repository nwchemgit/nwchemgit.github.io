<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="canonical" href="https://nwchemgit.github.io/Python.html">
  <link rel="shortcut icon" href="img/favicon.ico">
  <title>Controlling NWChem with Python - NWChem</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Controlling NWChem with Python";
    var mkdocs_page_input_path = "Python.md";
    var mkdocs_page_url = "/Python.html";
  </script>
  
  <script src="js/jquery-2.1.1.min.js" defer></script>
  <script src="js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="." class="icon icon-home"> NWChem</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Home.html">Documentation</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Download.html">Download</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Quantum-Mechanical-Methods.html">Quantum Mechanical Methods</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Quantum-Molecular-Dynamics.html">Quantum Molecular Dynamics</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Other-Capabilities.html">Other Capabilities</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Examples.html">Examples</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Supplementary-Information.html">Supplementary Information</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Compiling-NWChem.html">Compiling NWChem from source</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Benchmarks.html">Benchmarks performed with NWChem</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Tutorials.html">Tutorials</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Forum.html">Forum</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="Archived-Forum.html">Archived Forum</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href=".">NWChem</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".">Docs</a> &raquo;</li>
    
      
    
    <li>Controlling NWChem with Python</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/nwchemgit/nwchem-wiki/blob/master/Python.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="controlling-nwchem-with-python">Controlling NWChem with Python</h1>
<p>Python (version 1.5.1) programs may be embedded into the NWChem input
and used to control the execution of NWChem. Python is a very powerful
and widely used scripting language that provides useful things such as
variables, conditional branches and loops, and is also readily extended.
Example applications include scanning potential energy surfaces,
computing properties in a variety of basis sets, optimizing the energy
w.r.t. parameters in the basis set, computing polarizabilities with
finite field, and simple molecular dynamics.</p>
<p>Look in the NWChem contrib directory for useful scripts and examples.
Visit the Python web-site <a href="http://www.python.org">http://www.python.org</a> for a full manual and
lots of useful code and resources.</p>
<h2 id="how-to-input-and-run-a-python-program-inside-nwchem">How to input and run a Python program inside NWChem</h2>
<p>A Python program is input into NWChem inside a Python compound
directive.</p>
<p><code>python [print|noprint]</code><br />
<code>...</code><br />
<code>end</code></p>
<p>The END directive must be flush against the left margin (see the
Troubleshooting section for the reason why).</p>
<p>The program is by default printed to standard output when read, but this
may be disabled with the noprint keyword. Python uses indentation to
indicate scope (and the initial level of indentation must be zero),
whereas NWChem uses optional indentation only to make the input more
readable. For example, in Python, the contents of a loop, or
conditionally-executed block of code must be indented further than the
surrounding code. Also, Python attaches special meaning to several
symbols also used by NWChem. For these reasons, the input inside a
PYTHON compound directive is read verbatim except that if the first line
of the Python program is indented, the same amount of indentation is
removed from all subsequent lines. This is so that a program may be
indented inside the PYTHON input block for improved readability of the
NWChem input, while satisfying the constraint that when given to Python
the first line has zero indentation.</p>
<p>E.g., the following two sets of input specify the same Python program.</p>
<pre><code>python  
  print (&quot;Hello&quot;)
  print (&quot;Goodbye&quot;)
end

python  
print (&quot;Hello&quot;)
print (&quot;Goodbye&quot;)
end
</code></pre>

<p>whereas this program is in error since the indentation of the second
line is less than that of the first.</p>
<pre><code>python  
  print (&quot;Hello&quot;)
print (&quot;Goodbye&quot;)
end
</code></pre>

<p>The Python program is not executed until the following directive is
encountered</p>
<pre><code> task python
</code></pre>

<p>which is to maintain consistency with the behavior of NWChem in general.
The program is executed by all nodes. This enables the full
functionality and speed of NWChem to be accessible from Python, but
there are some gotchas</p>
<ul>
<li>Print statements and other output will be executed by all nodes so
    you will get a lot more output than probably desired unless the
    output is restricted to just one node (by convention node zero).</li>
<li>The calls to NWChem functions are all collective (i.e., all nodes
    must execute them). If these calls are not made collectively your
    program may deadlock (i.e., cease to make progress).</li>
<li>When writing to the database (rtdb_put()) it is the data from node
    zero that is written.</li>
<li>NWChem overrides certain default signal handlers so care must be
    taken when creating processes (see Section 38.3.11).</li>
</ul>
<h2 id="nwchem-extensions">NWChem extensions</h2>
<p>Since we have little experience using Python, the NWChem-Python
interface might change in a non-backwardly compatible fashion as we
discover better ways of providing useful functionality. We would
appreciate suggestions about useful things that can be added to the
NWChem-Python interface. In principle, nearly any Fortran or C routine
within NWChem can be extended to Python, but we are also interested in
ideas that will enable users to build completely new things. For
instance, how about being able to define your own energy functions that
can be used with the existing optimizers or dynamics package?</p>
<p>Python has been extended with a module named &ldquo;nwchem&rdquo; which is
automatically imported and contains the following NWChem-specific
commands. They all handle NWChem-related errors by raising the exception
&ldquo;NWChemError&rdquo;, which may be handled in the standard Python manner (see
Section 38.3.9).</p>
<ul>
<li>input_parse(string) &ndash; invokes the standard NWChem input parser
    with the data in string as input. Note that the usual behavior of
    NWChem will apply &ndash; the parser only reads input up to either end of
    input or until a TASK directive is encountered (the task directive
    is not executed by the parser).</li>
<li>task_energy(theory) &ndash; returns the energy as if computed with the
    NWChem directive TASK ENERGY <THEORY>.</li>
<li>task_gradient(theory) &ndash; returns a tuple (energy,gradient) as if
    computed with the NWChem directive TASK GRADIENT <THEORY>.</li>
<li>task_optimize(theory) &ndash; returns a tuple (energy,gradient) as if
    computed with the NWChem directive TASK OPTIMIZE <THEORY>. The
    energy and gradient will be those at the last point in the
    optimization and consistent with the current geometry in the
    database.</li>
<li>ga_nodeid() &ndash; returns the number of the parallel process.</li>
<li>rtdb_print(print_values) &ndash; prints the contents of the RTDB. If
    print_values is 0, only the keys are printed, if it is 1 then the
    values are also printed.</li>
<li>rtdb_put(name, values) or rtdb_put(name, values, type) &ndash; puts the
    values into the database with the given name. In the first form, the
    type is inferred from the first value, and in the second form the
    type is specified using the last argument as one of INT, DBL,
    LOGICAL, or CHAR.</li>
<li>rtdb_get(name) &ndash; returns the data from the database associated
    with the given name.</li>
</ul>
<p>An
<a href="#accessing-geometry-information----a-temporary-hack">example</a>
below explains, in lieu of a Python wrapper for the geometry object, how
to obtain the Cartesian molecular coordinates directly from the
database.</p>
<h2 id="examples">Examples</h2>
<p>Several examples will provide the best explanation of how the extensions
are used, and how Python might prove useful.</p>
<h3 id="hello-world">Hello world</h3>
<pre><code>python
  print ('Hello world from process %i'  % ga_nodeid())
end

task python
</code></pre>

<p>This input prints the traditional greeting from each parallel
process.</p>
<h3 id="scanning-a-basis-exponent">Scanning a basis exponent</h3>
<pre><code>geometry units au
 O 0 0 0; H 0 1.430 -1.107; H 0 -1.430 -1.107
end

python
exponent = 0.1
while (exponent &lt;= 2.01):
    input_parse('''                                                                                                
    basis noprint                                                                                                  
     H library 3-21g; O library 3-21g; O d; %f 1.0                                                                 
    end                                                                                                            
    ''' % (exponent))
    print (' exponent = %5.4f,' % exponent, ', energy = %16.10f' % task_energy('scf'))
    exponent = exponent + 0.1
end

print none

task python
</code></pre>

<p>This program augments a 3-21g basis for water with a d-function on
oxygen and varies the exponent from 0.1 to 2.0 in steps of 0.1, printing
the exponent and energy at each step.</p>
<p>The geometry is input as usual, but the basis set input is embedded
inside a call to input_parse() in the Python program. The standard
Python string substitution is used to put the current value of the
exponent into the basis set (replacing the %f) before being parsed by
NWChem. The energy is returned by task_energy(&lsquo;scf&rsquo;) and printed out.
The print none in the NWChem input switches off all NWChem output so all
you will see is the output from your Python program.</p>
<p>Note that execution in parallel may produce unwanted output since all
process execute the print statement inside the Python program.</p>
<p>Look in the NWChem contrib directory for a routine that makes the above
task easier.</p>
<h3 id="scanning-a-basis-exponent-revisited">Scanning a basis exponent revisited</h3>
<pre><code>geometry units au
O 0 0 0; H 0 1.430 -1.107; H 0 -1.430 -1.107
end


python
  if (ga_nodeid() == 0): plotdata = open(&quot;plotdata&quot;,'w')

  def energy_at_exponent(exponent):
    input_parse('''                                                                                                
    basis noprint                                                                                                  
      H library 3-21g; O library 3-21g; O d; %f 1.0                                                                
    end                                                                                                            
    ''' % (exponent))
    return task_energy('scf')

  exponent = 0.1
  while exponent &lt;= 2.01:
    energy = energy_at_exponent(exponent)
    if (ga_nodeid() == 0):
        print (' exponent = %5.4f,' % exponent, ', energy = %16.10f' % energy)
        plotdata.write('%f %f\n' % (exponent , energy))
    exponent = exponent + 0.1

  if (ga_nodeid() == 0): plotdata.close()
end

print none
task python
</code></pre>

<p>This input performs exactly the same calculation as the previous one,
but uses a slightly more sophisticated Python program, also writes the
data out to a file for easy visualization with a package such as
gnuplot, and protects write statements to prevent duplicate output in a
parallel job. The only significant differences are in the Python
program. A file called &ldquo;plotdata&rdquo; is opened, and then a procedure is
defined which given an exponent returns the energy. Next comes the main
loop that scans the exponent through the desired range and prints the
results to standard output and to the file. When the loop is finished
the additional output file is closed.</p>
<h3 id="scanning-a-geometric-variable">Scanning a geometric variable</h3>
<pre><code>python
   geometry = '''
     geometry noprint; symmetry d2h
        C 0 0 %f; H 0  0.916 1.224
     end
   '''
   x = 0.6
   while (x &lt; 0.721):
     input_parse(geometry % x)
     energy = task_energy('scf')
     print (' x = %5.2f   energy = %10.6f' % (x, energy))
     x = x + 0.01
end

basis; C library 6-31g*; H library 6-31g*; end

print none

task python
</code></pre>

<p>This scans the bond length in ethene from 1.2 to 1.44 in steps of 0.2
computing the energy at each geometry. Since it is using D<sub>2h</sub>
symmetry the program actually uses a variable (x) that is half the bond
length.</p>
<p>Look in the NWChem contrib directory for a routine that makes the above
task
easier.</p>
<h3 id="scan-using-the-bsse-counterpoise-corrected-energy">Scan using the BSSE counterpoise corrected energy</h3>
<pre><code>basis spherical
  Ne library cc-pvdz; BqNe library Ne cc-pvdz
  He library cc-pvdz; BqHe library He cc-pvdz
end

mp2; tight; freeze core atomic; end

print none

python
  supermolecule = 'geometry noprint;   Ne 0 0 0;   He 0 0 %f; end\n'
  fragment1     = 'geometry noprint;   Ne 0 0 0; BqHe 0 0 %f; end\n'
  fragment2     = 'geometry noprint; BqNe 0 0 0;   He 0 0 %f; end\n'

  def energy(geometry):
    input_parse(geometry + 'scf; vectors atomic; end\n')
    return task_energy('mp2')

  def bsse_energy(z):
    return energy(supermolecule % z) - \
        energy(fragment1 % z) - \
        energy(fragment2 % z)
  z = 3.3
  while (z &lt; 4.301):
    e = bsse_energy(z)
    if (ga_nodeid() == 0): print (' z = %5.2f   energy = %10.7f ' % (z, e))
    z = z + 0.1
end

task python
</code></pre>

<p>This example scans the He&ndash;Ne bond-length from 3.3 to 4.3 and prints out
the BSSE counterpoise corrected MP2 energy.</p>
<p>The basis set is specified as usual, noting that we will need functions
on ghost centers to do the counterpoise correction. The Python program
commences by defining strings containing the geometry of the
super-molecule and two fragments, each having one variable to be
substituted. Next, a function is defined to compute the energy given a
geometry, and then a function is defined to compute the counterpoise
corrected energy at a given bond length. Finally, the bond length is
scanned and the energy printed. When computing the energy, the atomic
guess has to be forced in the SCF since by default it will attempt to
use orbitals from the previous calculation which is not appropriate
here.</p>
<p>Since the counterpoise corrected energy is a linear combination of other
standard energies, it is possible to compute the analytic derivatives
term by term. Thus, combining this example and the next could yield the
foundation of a BSSE corrected geometry optimization
package.</p>
<h3 id="scan-the-geometry-and-compute-the-energy-and-gradient">Scan the geometry and compute the energy and gradient</h3>
<pre><code> basis noprint; H library sto-3g; O library sto-3g; end

 python
 print ('   y     z     energy                gradient')
 print (' ----- ----- ---------- ------------------------------------')
 y = 1.2
 while y &lt;= 1.61:
     z = 1.0
     while z &lt;= 1.21:
         input_parse('''
           geometry noprint units atomic
             O 0   0   0
             H 0  %f -%f
             H 0 -%f -%f
           end
         ''' % (y, z, y, z))

         (energy,gradient) = task_gradient('scf')

         print (' %5.2f %5.2f %9.6f' % (y, z, energy)),
         i = 0
         while (i &lt; len(gradient)):
             print ('%5.2f' % gradient[i]),
             i = i + 1
         print ('')
     z = z + 0.1
 y = y + 0.1
end

print none

task python
</code></pre>

<p>This program illustrates evaluating the energy and gradient by calling
task_gradient(). A water molecule is scanned through several C<sub>2v</sub>
geometries by varying the y and z coordinates of the two hydrogen atoms.
At each geometry the coordinates, energy and gradient are printed.</p>
<p>The basis set (sto-3g) is input as usual. The two while loops vary the y
and z coordinates. These are then substituted into a geometry which is
parsed by NWChem using <code>input_parse()</code>. The energy and gradient are then
evaluated by calling <code>task_gradient()</code> which returns a tuple containing
the energy (a scalar) and the gradient (a vector or list). These are
printed out exploiting the Python convention that a print statement
ending in a comma does not print end-of-line.</p>
<h3 id="reaction-energies-varying-the-basis-set">Reaction energies varying the basis set</h3>
<pre><code>mp2; freeze atomic; end

print none

python
  energies = {}
  c2h4 = 'geometry noprint; symmetry d2h; \
          C 0 0 0.672; H 0 0.935 1.238; end\n'
  ch4  = 'geometry noprint; symmetry td; \
          C 0 0 0; H 0.634 0.634 0.634; end\n'
  h2   = 'geometry noprint; H 0 0 0.378; H 0 0 -0.378; end\n'

  def energy(basis, geometry):
    input_parse('''
      basis spherical noprint
        c library %s ; h library %s 
      end
    ''' % (basis, basis))
    input_parse(geometry)
    return task_energy('mp2')

  for basis in ('sto-3g', '6-31g', '6-31g*', 'cc-pvdz', 'cc-pvtz'):
     energies[basis] =   2*energy(basis, ch4) \
                       - 2*energy(basis, h2) - energy(basis, c2h4)
     if (ga_nodeid() == 0): print (basis, ' %8.6f' % energies[basis])
end 

task python
</code></pre>

<p>In this example the reaction energy for  2H<sub>2</sub> + C<sub>2</sub>H<sub>4</sub> &rarr;
2CH<sub>4</sub> is evaluated using MP2 in several basis sets. The geometries are
fixed, but could be re-optimized in each basis. To illustrate the useful
associative arrays in Python, the reaction energies are put into the
associative array energies &ndash; note its declaration at the top of the
program.</p>
<h3 id="using-the-database">Using the database</h3>
<p><code>python</code><br />
<code>rtdb_put("test_int2", 22)</code><br />
<code>rtdb_put("test_int", [22, 10, 3],    INT)</code><br />
<code>rtdb_put("test_dbl", [22.9, 12.4, 23.908],  DBL)</code><br />
<code>rtdb_put("test_str", "hello", CHAR)</code><br />
<code>rtdb_put("test_logic", [0,1,0,1,0,1], LOGICAL)</code><br />
<code>rtdb_put("test_logic2", 0, LOGICAL)</code><br />
<code></code><br />
<code>rtdb_print(1)</code><br />
<code></code><br />
<code>print "test_str    = ", rtdb_get("test_str")</code><br />
<code>print "test_int    = ", rtdb_get("test_int")</code><br />
<code>print "test_in2    = ", rtdb_get("test_int2")</code><br />
<code>print "test_dbl    = ", rtdb_get("test_dbl")</code><br />
<code>print "test_logic  = ", rtdb_get("test_logic")</code><br />
<code>print "test_logic2 = ", rtdb_get("test_logic2")</code><br />
<code>end</code><br />
<code></code><br />
<code>task python</code></p>
<p>This example illustrates how to access the database from Python.</p>
<h3 id="handling-exceptions-from-nwchem">Handling exceptions from NWChem</h3>
<p><code>geometry; he 0 0 0; he 0 0 2; end</code><br />
<code>basis; he library 3-21g; end</code><br />
<code>scf; maxiter 1; end</code><br />
<code></code><br />
<code>python</code><br />
<code>try:</code><br />
<code>task_energy('scf')</code><br />
<code>except NWChemError, message:</code><br />
<code>print 'Error from NWChem ... ', message</code><br />
<code>end</code><br />
<code></code><br />
<code>task python</code></p>
<p>The above test program shows how to handle exceptions generated by
NWChem by forcing an SCF calculation on (He_2) to fail due to
insufficient iterations.</p>
<p>If an NWChem command fails it will raise the exception &ldquo;NWChemError&rdquo;
(case sensitive) unless the error was fatal. If the exception is not
caught, then it will cause the entire Python program to terminate with
an error. This Python program catches the exception, prints out the
message, and then continues as if all was well since the exception has
been handled.</p>
<p>If your Python program detects an error, raise an unhandled exception.
Do not call exit(1) since this may circumvent necessary clean-up of the
NWChem execution environment.</p>
<h3 id="accessing-geometry-information-a-temporary-hack">Accessing geometry information &ndash; a temporary hack</h3>
<p>In an ideal world the geometry and basis set objects would have full
Python wrappers, but until then a back-door solution will have to
suffice. We&rsquo;ve already seen how to use input_parse() to put geometry
(and basis) data into NWChem, so it only remains to get the geometry
data back after it has been updated by a geometry optimzation or some
other operation.</p>
<p>The following Python procedure retrieves the coordinates in the same
units as initially input for a geometry of a given name. Its full source
is included in the NWChem contrib directory.</p>
<p><code>def geom_get_coords(name):</code><br />
<code>try:</code><br />
<code>actualname = rtdb_get(name)</code><br />
<code>except NWChemError:</code><br />
<code>actualname = name</code><br />
<code>coords = rtdb_get('geometry:' + actualname + ':coords')</code><br />
<code>units  = rtdb_get('geometry:' + actualname + ':user units')</code><br />
<code>if (units == 'a.u.'):</code><br />
<code>factor = 1.0</code><br />
<code>elif (units == 'angstroms'):</code><br />
<code>factor = rtdb_get('geometry:'+actualname+':angstrom_to_au')</code><br />
<code>else:</code><br />
<code>raise NWChemError,'unknown units'</code><br />
<code>i = 0</code><br />
<code>while (i &lt; len(coords)):</code><br />
<code>coords[i] = coords[i] / factor</code><br />
<code>i = i + 1</code><br />
<code>return coords</code></p>
<p>A <a href="Geometry.html">geometry</a> with name NAME has its coordinates (in
atomic units) stored in the database entry geometry:NAME:coords. A minor
wrinkle here is that indirection is possible (and used by the
optimizers) so that we must first check if NAME actually points to
another name. In the program this is done in the first try&hellip;except
sequence. With the actual name of the geometry, we can get the
coordinates. Any exceptions are passed up to the caller. The rest of the
code is just to convert back into the initial input units &ndash; only atomic
units or Angstrøms are handled in this simple example. Returned is a
list of the atomic coordinates in the same units as your initial input.</p>
<p>The routine is used as follows</p>
<p><code>coords = geom_get_coords('geometry')</code></p>
<p>or, if you want better error handling</p>
<p><code>try:</code><br />
<code>coords = geom_get_coords('geometry')</code><br />
<code>except NWChemError,message:</code><br />
<code>print 'Coordinates for geometry not found ', message</code><br />
<code>else:</code><br />
<code>print coords</code></p>
<p>This is very dirty and definitely not supported from one release to
another, but, browsing the output of rtdb_print() at the end of a
calculation is a good way to find stuff. To be on safer ground, look in
the programmers manual since some of the high-level routines do pass
data via the database in a well-defined and supported manner. Be warned
&ndash; you must be very careful if you try to modify data in the database.
The input parser does many important things that are not immediately
apparent (e.g., ensure the geometry is consistent with the point group,
mark the SCF as not converged if the SCF options are changed, &hellip;).
Where at all possible your Python program should generate standard
NWChem input and pass it to input_parse() rather than setting
parameters directly in the
database.</p>
<h3 id="scaning-a-basis-exponent-yet-again-plotting-and-handling-child-processes">Scaning a basis exponent yet again &ndash; plotting and handling child processes</h3>
<pre><code> geometry units au  
   O 0 0 0; H 0 1.430 -1.107; H 0 -1.430 -1.107  
 end  
    
 print none  
    
 python  
   import Gnuplot, time, signal  
     
   def energy_at_exponent(exponent):  
      input_parse('''  
         basis noprint  
            H library 3-21g; O library 3-21g; O d; %f 1.0  
         end  
      ''' % (exponent))  
      return task_energy('scf')  
      
   data = []  
   exponent = 0.5  
   while exponent &lt;= 0.6:  
      energy = energy_at_exponent(exponent)  
      print ' exponent = ', exponent, ' energy = ', energy  
      data = data + [exponent,energy](exponent,energy.md)  
      exponent = exponent + 0.02  
      
   if (ga_nodeid() == 0):  
      signal.signal(signal.SIGCHLD, signal.SIG_DFL)  
      g = Gnuplot.Gnuplot()  
      g('set data style linespoints')  
      g.plot(data)  
      time.sleep(30)  # 30s to look at the plot  
     
 end  
     
 task python
</code></pre>

<p>This illustrates how to handle signals from terminating child processes
and how to generate simple plots on UNIX systems. The <a href="#scanning-a-basis-exponent-revisited">scanning
example</a> is modified so
that instead of writing the data to a file for subsequent visualization,
it is saved for subsequent visualization with Gnuplot (you&rsquo;ll need both
Gnuplot and the corresponding package for Python in your PYTHONPATH.
Look at <a href="http://monsoon.harvard.edu/~mhagger/download">http://monsoon.harvard.edu/~mhagger/download</a>).</p>
<p>The issue is that NWChem traps various signals from the O/S that usually
indicate bad news in order to provide better error handling and reliable
clean-up of shared, parallel resources. One of these signals is SIGCHLD
which is generated whenever a child process terminates. If you want to
create child processes within Python, then the NWChem handler for
SIGCHLD must be replaced with the default handler. There seems to be no
easy way to restore the NWChem handler after the child has completed,
but this should have no serious side effect.</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<p>Common problems with Python programs inside NWChem.</p>
<ol>
<li>
<p>You get the message  </p>
<p>0:python_input: indentation must be >= that of first line: 4  </p>
<p>This indicates that NWChem thinks that a line is less indented than
the first line. If this is not the case then perhaps there is a tab
in your input which NWChem treats as a single space character but
appears to you as more spaces. Try running untabify in Emacs. The
problem could also be the END directive that terminates the PYTHON
compound directive &ndash; since Python also has an end statement. To
avoid confusion the END directive for NWChem must be at the start of
the line.  </p>
</li>
<li>
<p>Your program hangs or deadlocks &ndash; most likely you have a piece of
    code that is restricted to executing on a subset of the processors
    (perhaps just node 0) but is calling (perhaps indirectly) a function
    that must execute on all nodes.</p>
</li>
</ol>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/nwchemgit/nwchem-wiki/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
      
    </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
